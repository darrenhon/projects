Assignment Overview

  To my understanding, the purpose of this project is to get a hands-on experience on single-threaded socket programming, with particular emphasis on robustness and error handling. Socket programming, at the first impression, might be treated as an easy exercise for beginners. But when considering real world circumstances, the complexity grows to a whole new level. Even for a single-threaded exercise, every single part can go wrong. For example when creating the socket, establishing connection, reading data, transmitting data, closing socket, etc. In this project, we learned how to deal with all these mishaps - catch the exception, write down log with all the important information, then continue with execution or terminate the program gracefully. This is an important step towards enterprise quality software where they have to deal with the worst possible cases with grace, and in case of failure, gather enough information for recovery and troubleshooting. 
  We also learned to design our own communication protocol between server and client. This is also an important step towards distributed system design. When designing our own data format, we balanced between flexibility, extensibility, robustness, and efficiency on utilizing network resources. These are fundamental considerations at the beginning stage of distributed system design.
  After finishing this project, we should have built a solid foundation on TCP and UDP socket programming, which are the basic building blocks of the higher levels of distributed systems that we will be building for the rest of this course.


Technical Impression

  To me, this project is not entirely technically challenging, but several thoughts come to my mind when working on it. They are listed in bullet points:

- The language I’m most familiar with is C#. Due to its poor portability I’m concerned that it will cause trouble for grader or professor to run or read the program. I changed to Java, which is not very familiar to me. So there is a bit of learning curve.
- The project can be done in some fancy way but I choose to keep it simple. For example I can combine the TCPServer and UDPServer into 1 server interface, which is then implemented by 2 server classes for TCP and UDP. I can do the same for TCPClient and UDPClient, so that the switching between TCP and UDP can be done in the same program. But I think it introduces some unnecessary complexity to the code that deviates from the main purpose of this project. So even if there are quite a bit of code duplication, I decided to split TCP and UDP into individual programs, and make the classes structures as flat as possible. 
- I was constantly evaluating the level of expectation of the grader and professor when I’m making some design decisions. For example, if I don’t break down long methods into multiple shorter ones, will I get marks deducted? How much information is enough in the log? How much tolerance is expected for server to parse data from client? How much interaction between user and the program is needed? These are not very clearly stated in the specification. It not quite possible to specify into so much details either.
